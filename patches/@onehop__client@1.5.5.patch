diff --git a/dist/onehop-client.esm.js b/dist/onehop-client.esm.js
index 689f16eb5af845703be0a7d339105a0b29bb0b68..444791312a8253a670b8d56869079942209dda8d 100644
--- a/dist/onehop-client.esm.js
+++ b/dist/onehop-client.esm.js
@@ -1,8 +1,6 @@
 import { LeapConnectionState, LeapEdgeClient } from '@onehop/leap-edge-js';
 export { LeapConnectionState as ConnectionState } from '@onehop/leap-edge-js';
-import Hls__default from 'hls.js';
-import * as Hls from 'hls.js';
-export { Hls as hls };
+export { hop, index$1 as leap, index$2 as util };
 
 /**
  * An atom, inspired much by Jotai, is a single bit of readible
@@ -14,977 +12,857 @@ export { Hls as hls };
  * @returns A readible and observable state object
  */
 function atom(initialValue) {
-  let atomValue = initialValue === undefined ? {
-    uninitialized: true,
-    value: undefined
-  } : {
-    value: initialValue
-  };
-  const listeners = new Set();
-
-  const notify = () => {
-    if ('uninitialized' in atomValue) {
-      // In theory this would never happen
-      // because the value would have
-      // already been set and therefore
-      // not unintialized
-      return;
-    }
-
-    for (const listener of listeners) {
-      listener(atomValue.value);
-    }
-  };
-
-  return {
-    get() {
-      if ('uninitialized' in atomValue) {
-        throw new Error('Cannot read the value of an atom that has no value yet.');
-      }
-
-      return atomValue.value;
-    },
-
-    set(value) {
-      // Be efficient and don't update
-      if (Object.is(atomValue.value, value)) {
-        return;
-      }
-
-      atomValue = {
-        value
-      };
-      notify();
-    },
-
-    addListener(listener) {
-      listeners.add(listener);
-      return () => {
-        listeners.delete(listener);
-      };
-    },
+    let atomValue =
+        initialValue === undefined
+            ? {
+                  uninitialized: true,
+                  value: undefined,
+              }
+            : {
+                  value: initialValue,
+              };
+    const listeners = new Set();
+
+    const notify = () => {
+        if ('uninitialized' in atomValue) {
+            // In theory this would never happen
+            // because the value would have
+            // already been set and therefore
+            // not unintialized
+            return;
+        }
 
-    removeListener(listener) {
-      listeners.delete(listener);
-    }
+        for (const listener of listeners) {
+            listener(atomValue.value);
+        }
+    };
 
-  };
+    return {
+        get() {
+            if ('uninitialized' in atomValue) {
+                throw new Error(
+                    'Cannot read the value of an atom that has no value yet.'
+                );
+            }
+
+            return atomValue.value;
+        },
+
+        set(value) {
+            // Be efficient and don't update
+            if (Object.is(atomValue.value, value)) {
+                return;
+            }
+
+            atomValue = {
+                value,
+            };
+            notify();
+        },
+
+        addListener(listener) {
+            listeners.add(listener);
+            return () => {
+                listeners.delete(listener);
+            };
+        },
+
+        removeListener(listener) {
+            listeners.delete(listener);
+        },
+    };
 }
 
-var atoms = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	create: atom
+var atoms = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    create: atom,
 });
 
 const getMessageListenerKey = (channel, event) => `${channel}:${event}`;
 
-var channels = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	getMessageListenerKey: getMessageListenerKey
+var channels = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    getMessageListenerKey: getMessageListenerKey,
 });
 
 class HopEmitter {
-  constructor() {
-    this.listeners = new Map();
-  }
-
-  createListener(_key, fn) {
-    return fn;
-  }
-  /**
-   * Subscribe and listen to an event
-   * @param key The event name to listen for
-   * @param listener A listener for this event
-   * @returns A function that can be called to unsubscribe the listener
-   * @example
-   * ```
-   * const unsubscribe = client.on('MESSAGE', console.log);
-   * // Unsubscribe later...
-   * unsubscribe();
-   * ```
-   */
-
-
-  on(key, listener) {
-    const existing = this.listeners.get(key) ?? [];
-    const merged = new Set([...existing, listener]);
-    this.listeners.set(key, merged);
-    return () => {
-      const set = this.listeners.get(key);
-
-      if (!set) {
-        return;
-      }
-
-      if (set.size === 0) {
-        this.listeners.delete(key);
-      }
-
-      set.delete(listener);
-    };
-  }
-  /**
-   * Subscribe and listen to an event once only
-   * @param key The event name to listen for
-   * @param listener A listener for this event
-   * @returns A function that can be called to unsubscribe the listener before it even runs
-   */
+    constructor() {
+        this.listeners = new Map();
+    }
+
+    createListener(_key, fn) {
+        return fn;
+    }
+    /**
+     * Subscribe and listen to an event
+     * @param key The event name to listen for
+     * @param listener A listener for this event
+     * @returns A function that can be called to unsubscribe the listener
+     * @example
+     * ```
+     * const unsubscribe = client.on('MESSAGE', console.log);
+     * // Unsubscribe later...
+     * unsubscribe();
+     * ```
+     */
+
+    on(key, listener) {
+        const existing = this.listeners.get(key) ?? [];
+        const merged = new Set([...existing, listener]);
+        this.listeners.set(key, merged);
+        return () => {
+            const set = this.listeners.get(key);
+
+            if (!set) {
+                return;
+            }
+
+            if (set.size === 0) {
+                this.listeners.delete(key);
+            }
+
+            set.delete(listener);
+        };
+    }
+    /**
+     * Subscribe and listen to an event once only
+     * @param key The event name to listen for
+     * @param listener A listener for this event
+     * @returns A function that can be called to unsubscribe the listener before it even runs
+     */
+
+    once(key, listener) {
+        const unsubscribe = this.on(key, (data) => {
+            unsubscribe();
+            return listener(data);
+        });
+        return unsubscribe;
+    }
+    /**
+     * Remove a listener from an event
+     * @param key The event name to remove a listener from
+     * @param listener The listener to remove
+     */
+
+    off(key, listener) {
+        const set = this.listeners.get(key);
+
+        if (!set) {
+            throw new Error(
+                "Cannot remove listener for key that doesn't exist."
+            );
+        }
+
+        if (set.size === 0) {
+            this.listeners.delete(key);
+            return;
+        }
 
+        set.delete(listener);
+    }
+    /**
+     * Emit an event to all listeners
+     * @param key The event name to emit
+     * @param data The data to emit
+     */
 
-  once(key, listener) {
-    const unsubscribe = this.on(key, data => {
-      unsubscribe();
-      return listener(data);
-    });
-    return unsubscribe;
-  }
-  /**
-   * Remove a listener from an event
-   * @param key The event name to remove a listener from
-   * @param listener The listener to remove
-   */
+    emit(key, data) {
+        const listeners = this.listeners.get(key);
 
+        if (!listeners) {
+            return;
+        } // In theory, shouldn't happen because we should have already checked
+        // in the .off call
 
-  off(key, listener) {
-    const set = this.listeners.get(key);
+        if (listeners.size === 0) {
+            this.listeners.delete(key);
+            return;
+        }
 
-    if (!set) {
-      throw new Error("Cannot remove listener for key that doesn't exist.");
+        for (const listener of listeners) {
+            listener(data);
+        }
     }
+}
+
+class HopEmitterInitialiser extends HopEmitter {
+    static create = () => new HopEmitter();
+}
+
+const { create } = HopEmitterInitialiser;
+
+var emitter = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    HopEmitter: HopEmitter,
+    create: create,
+});
+
+class ObservableMap {
+    map = new Map();
+    listeners = new Set();
 
-    if (set.size === 0) {
-      this.listeners.delete(key);
-      return;
+    get size() {
+        return this.map.size;
     }
 
-    set.delete(listener);
-  }
-  /**
-   * Emit an event to all listeners
-   * @param key The event name to emit
-   * @param data The data to emit
-   */
+    get [Symbol.toStringTag]() {
+        return 'ObservableMap';
+    }
 
+    clear() {
+        this.map.clear();
+        this.notify({
+            type: 'clear',
+        });
+    }
 
-  emit(key, data) {
-    const listeners = this.listeners.get(key);
+    delete(key) {
+        const success = this.map.delete(key);
+        this.notify({
+            type: 'delete',
+            key,
+        });
+        return success;
+    }
 
-    if (!listeners) {
-      return;
-    } // In theory, shouldn't happen because we should have already checked
-    // in the .off call
+    forEach(callbackfn, thisArg) {
+        this.map.forEach(callbackfn, thisArg);
+    }
 
+    get(key) {
+        return this.map.get(key);
+    }
 
-    if (listeners.size === 0) {
-      this.listeners.delete(key);
-      return;
+    has(key) {
+        return this.map.has(key);
     }
 
-    for (const listener of listeners) {
-      listener(data);
+    set(key, value) {
+        this.map.set(key, value);
+        this.notify({
+            type: 'set',
+            key,
+            value,
+        });
+        return this;
     }
-  }
 
-}
+    patch(key, value) {
+        const old = this.map.get(key);
 
-class HopEmitterInitialiser extends HopEmitter {
-  static create = () => new HopEmitter();
-}
+        if (old === undefined) {
+            throw new Error(
+                'Cannot patch a value that does not already exist. Use `.set` instead.'
+            );
+        }
 
-const {
-  create
-} = HopEmitterInitialiser;
+        return this.set(key, { ...old, ...value });
+    }
+    /**
+     * Merge with another map, with the new map overwriting members with the same key
+     * @param map A map that has a matching set of keys and values
+     */
 
-var emitter = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	HopEmitter: HopEmitter,
-	create: create
-});
+    merge(map) {
+        this.map = new Map([...this.map, ...map]);
+        this.notify({
+            type: 'merge',
+        });
+    }
 
-class ObservableMap {
-  map = new Map();
-  listeners = new Set();
-
-  get size() {
-    return this.map.size;
-  }
-
-  get [Symbol.toStringTag]() {
-    return 'ObservableMap';
-  }
-
-  clear() {
-    this.map.clear();
-    this.notify({
-      type: 'clear'
-    });
-  }
-
-  delete(key) {
-    const success = this.map.delete(key);
-    this.notify({
-      type: 'delete',
-      key
-    });
-    return success;
-  }
-
-  forEach(callbackfn, thisArg) {
-    this.map.forEach(callbackfn, thisArg);
-  }
-
-  get(key) {
-    return this.map.get(key);
-  }
-
-  has(key) {
-    return this.map.has(key);
-  }
-
-  set(key, value) {
-    this.map.set(key, value);
-    this.notify({
-      type: 'set',
-      key,
-      value
-    });
-    return this;
-  }
-
-  patch(key, value) {
-    const old = this.map.get(key);
-
-    if (old === undefined) {
-      throw new Error('Cannot patch a value that does not already exist. Use `.set` instead.');
-    }
-
-    return this.set(key, { ...old,
-      ...value
-    });
-  }
-  /**
-   * Merge with another map, with the new map overwriting members with the same key
-   * @param map A map that has a matching set of keys and values
-   */
-
-
-  merge(map) {
-    this.map = new Map([...this.map, ...map]);
-    this.notify({
-      type: 'merge'
-    });
-  }
-
-  entries() {
-    return this.map.entries();
-  }
-
-  keys() {
-    return this.map.keys();
-  }
-
-  values() {
-    return this.map.values();
-  }
-
-  [Symbol.iterator]() {
-    return this.map[Symbol.iterator]();
-  }
-
-  addListener(listener) {
-    this.listeners.add(listener);
-    return () => {
-      this.listeners.delete(listener);
-    };
-  }
+    entries() {
+        return this.map.entries();
+    }
+
+    keys() {
+        return this.map.keys();
+    }
 
-  removeListener(listener) {
-    this.listeners.delete(listener);
-  }
+    values() {
+        return this.map.values();
+    }
+
+    [Symbol.iterator]() {
+        return this.map[Symbol.iterator]();
+    }
 
-  notify(payload) {
-    for (const listener of this.listeners) {
-      listener(this, payload);
+    addListener(listener) {
+        this.listeners.add(listener);
+        return () => {
+            this.listeners.delete(listener);
+        };
     }
-  }
 
+    removeListener(listener) {
+        this.listeners.delete(listener);
+    }
+
+    notify(payload) {
+        for (const listener of this.listeners) {
+            listener(this, payload);
+        }
+    }
 }
 
-var maps = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	ObservableMap: ObservableMap
+var maps = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    ObservableMap: ObservableMap,
 });
 
 /**
  * A queue that can be used to store items in a first-in-first-out order.
  */
 class FIFOQueue {
-  items = [];
+    items = [];
 
-  enqueue(item) {
-    this.items.push(item);
-  }
-
-  dequeue() {
-    return this.items.shift();
-  }
+    enqueue(item) {
+        this.items.push(item);
+    }
 
-  peek() {
-    return this.items[0];
-  }
+    dequeue() {
+        return this.items.shift();
+    }
 
-  get length() {
-    return this.items.length;
-  }
+    peek() {
+        return this.items[0];
+    }
 
-  isEmpty() {
-    return this.items.length === 0;
-  }
+    get length() {
+        return this.items.length;
+    }
 
+    isEmpty() {
+        return this.items.length === 0;
+    }
 }
 /**
  * A queue that can be used to store items in a last-in-first-out order.
  */
 
 class LIFOQueue {
-  items = [];
-
-  enqueue(item) {
-    this.items.push(item);
-  }
+    items = [];
 
-  dequeue() {
-    return this.items.pop();
-  }
+    enqueue(item) {
+        this.items.push(item);
+    }
 
-  peek() {
-    return this.items[this.items.length - 1];
-  }
+    dequeue() {
+        return this.items.pop();
+    }
 
-  get length() {
-    return this.items.length;
-  }
+    peek() {
+        return this.items[this.items.length - 1];
+    }
 
-  isEmpty() {
-    return this.items.length === 0;
-  }
+    get length() {
+        return this.items.length;
+    }
 
+    isEmpty() {
+        return this.items.length === 0;
+    }
 }
 
-var queues = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	FIFOQueue: FIFOQueue,
-	LIFOQueue: LIFOQueue
+var queues = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    FIFOQueue: FIFOQueue,
+    LIFOQueue: LIFOQueue,
 });
 
-var index$2 = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	atoms: atoms,
-	channels: channels,
-	emitter: emitter,
-	maps: maps,
-	queues: queues
+var index$2 = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    atoms: atoms,
+    channels: channels,
+    emitter: emitter,
+    maps: maps,
+    queues: queues,
 });
 
 function createLeapEvent(config) {
-  return {
-    async handle(client, event) {
-      const requireId = config.requireId !== false;
-
-      if (!event.channelId && requireId) {
-        throw new Error(`Received opcode for ${event.eventType} but expected an ID that was not there.`);
-      }
+    return {
+        async handle(client, event) {
+            const requireId = config.requireId !== false;
 
-      await config.handle(client, event.channelId, event.data);
-    }
+            if (!event.channelId && requireId) {
+                throw new Error(
+                    `Received opcode for ${event.eventType} but expected an ID that was not there.`
+                );
+            }
 
-  };
+            await config.handle(client, event.channelId, event.data);
+        },
+    };
 }
 
 const AVAILABLE = createLeapEvent({
-  async handle(client, channelId, data) {
-    client.getChannelStateMap().set(channelId, {
-      error: null,
-      state: data.channel.state,
-      subscription: 'available'
-    });
-  }
-
+    async handle(client, channelId, data) {
+        client.getChannelStateMap().set(channelId, {
+            error: null,
+            state: data.channel.state,
+            subscription: 'available',
+        });
+    },
 });
 
 const DIRECT_MESSAGE = createLeapEvent({
-  requireId: false,
-
-  async handle(client, channel, data) {
-    const {
-      e: event,
-      d: messageData
-    } = data;
-    client.emit('MESSAGE', {
-      event,
-      data: messageData,
-      channel: null
-    });
-    const listeners = client.getDirectMessageListeners().get(event);
-
-    if (!listeners) {
-      return;
-    }
+    requireId: false,
+
+    async handle(client, channel, data) {
+        const { e: event, d: messageData } = data;
+        client.emit('MESSAGE', {
+            event,
+            data: messageData,
+            channel: null,
+        });
+        const listeners = client.getDirectMessageListeners().get(event);
 
-    if (listeners.size === 0) {
-      client.getDirectMessageListeners().delete(event);
-      return;
-    }
+        if (!listeners) {
+            return;
+        }
 
-    for (const listener of listeners) {
-      listener(messageData);
-    }
-  }
+        if (listeners.size === 0) {
+            client.getDirectMessageListeners().delete(event);
+            return;
+        }
 
+        for (const listener of listeners) {
+            listener(messageData);
+        }
+    },
 });
 
 const INIT = createLeapEvent({
-  requireId: false,
+    requireId: false,
 
-  async handle(client, channelId, data) {
-    const localState = new Map();
+    async handle(client, channelId, data) {
+        const localState = new Map();
 
-    for (const channel of data.channels) {
-      localState.set(channel.id, {
-        state: channel.state,
-        subscription: 'available',
-        error: null
-      });
-    }
-
-    client.getChannelStateMap().merge(localState);
-  }
+        for (const channel of data.channels) {
+            localState.set(channel.id, {
+                state: channel.state,
+                subscription: 'available',
+                error: null,
+            });
+        }
 
+        client.getChannelStateMap().merge(localState);
+    },
 });
 
 const MESSAGE = createLeapEvent({
-  async handle(client, channel, data) {
-    const {
-      e: event,
-      d: messageData
-    } = data;
-    client.emit('MESSAGE', {
-      event,
-      data: messageData,
-      channel
-    });
-    const key = getMessageListenerKey(channel, event);
-    const listeners = client.getChannelMessageListeners().get(key);
-
-    if (!listeners) {
-      return;
-    }
+    async handle(client, channel, data) {
+        const { e: event, d: messageData } = data;
+        client.emit('MESSAGE', {
+            event,
+            data: messageData,
+            channel,
+        });
+        const key = getMessageListenerKey(channel, event);
+        const listeners = client.getChannelMessageListeners().get(key);
 
-    if (listeners.size === 0) {
-      client.getChannelMessageListeners().delete(key);
-      return;
-    }
+        if (!listeners) {
+            return;
+        }
 
-    for (const listener of listeners) {
-      listener(messageData);
-    }
-  }
+        if (listeners.size === 0) {
+            client.getChannelMessageListeners().delete(key);
+            return;
+        }
 
+        for (const listener of listeners) {
+            listener(messageData);
+        }
+    },
 });
 
 const PIPE_ROOM_AVAILABLE = createLeapEvent({
-  requireId: false,
-
-  async handle(client, _, data) {
-    client.getRoomStateMap().set(data.pipe_room.join_token, {
-      subscription: 'available',
-      room: data.pipe_room,
-      connection: data.connection
-    });
-  }
+    requireId: false,
 
+    async handle(client, _, data) {
+        client.getRoomStateMap().set(data.pipe_room.join_token, {
+            subscription: 'available',
+            room: data.pipe_room,
+            connection: data.connection,
+        });
+    },
 });
 
 const PIPE_ROOM_UNAVAILABLE = createLeapEvent({
-  requireId: false,
-
-  async handle(client, _, data) {
-    client.getRoomStateMap().set(data.join_token, {
-      subscription: 'unavailable',
-      error: data,
-      room: null
-    });
-  }
+    requireId: false,
 
+    async handle(client, _, data) {
+        client.getRoomStateMap().set(data.join_token, {
+            subscription: 'unavailable',
+            error: data,
+            room: null,
+        });
+    },
 });
 
 const PIPE_ROOM_UPDATE = PIPE_ROOM_AVAILABLE;
 
 const STATE_UPDATE = createLeapEvent({
-  async handle(client, channel, data) {
-    client.emit('STATE_UPDATE', {
-      channel,
-      state: data.state
-    });
-    client.getChannelStateMap().patch(channel, {
-      state: data.state
-    });
-  }
-
+    async handle(client, channel, data) {
+        client.emit('STATE_UPDATE', {
+            channel,
+            state: data.state,
+        });
+        client.getChannelStateMap().patch(channel, {
+            state: data.state,
+        });
+    },
 });
 
 const TOKEN_STATE_UPDATE = createLeapEvent({
-  async handle(client, channelId, data) {
-    client.getChannelStateMap().patch(channelId, {
-      state: data.state
-    });
-  }
-
+    async handle(client, channelId, data) {
+        client.getChannelStateMap().patch(channelId, {
+            state: data.state,
+        });
+    },
 });
 
 const UNAVAILABLE = createLeapEvent({
-  async handle(client, channel, data) {
-    client.getChannelStateMap().set(channel, {
-      state: null,
-      subscription: 'unavailable',
-      error: data
-    });
-  }
-
+    async handle(client, channel, data) {
+        client.getChannelStateMap().set(channel, {
+            state: null,
+            subscription: 'unavailable',
+            error: data,
+        });
+    },
 });
 
 class Client extends HopEmitter {
-  static SUPPORTED_EVENTS = {
-    INIT,
-    AVAILABLE,
-    UNAVAILABLE,
-    STATE_UPDATE,
-    TOKEN_STATE_UPDATE,
-    MESSAGE,
-    DIRECT_MESSAGE,
-    PIPE_ROOM_UNAVAILABLE,
-    PIPE_ROOM_AVAILABLE,
-    PIPE_ROOM_UPDATE
-  };
-  hasPreviouslyConnected = false;
-  connectionState = atom(LeapConnectionState.IDLE);
-  leap = null;
-  channelStateMap = new ObservableMap();
-  channelMessageListeners = new Map();
-  directMessageListeners = new Map();
-  roomStateMap = new ObservableMap();
-  rawServiceEventListeners = new Set(); // Rule is broken — constructor is not useless because HopEmitter#constructor is protected
-  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
-
-  constructor() {
-    super();
-  }
-
-  connect(auth, opts) {
-    if (this.leap) {
-      return;
-    }
-
-    const leap = this.getLeap(auth, opts);
-
-    const serviceEvent = async message => {
-      this.emit('SERVICE_EVENT', message);
-      await this.handleServiceEvent(message);
+    static SUPPORTED_EVENTS = {
+        INIT,
+        AVAILABLE,
+        UNAVAILABLE,
+        STATE_UPDATE,
+        TOKEN_STATE_UPDATE,
+        MESSAGE,
+        DIRECT_MESSAGE,
+        PIPE_ROOM_UNAVAILABLE,
+        PIPE_ROOM_AVAILABLE,
+        PIPE_ROOM_UPDATE,
     };
+    hasPreviouslyConnected = false;
+    connectionState = atom(LeapConnectionState.IDLE);
+    leap = null;
+    channelStateMap = new ObservableMap();
+    channelMessageListeners = new Map();
+    directMessageListeners = new Map();
+    roomStateMap = new ObservableMap();
+    rawServiceEventListeners = new Set(); // Rule is broken — constructor is not useless because HopEmitter#constructor is protected
+    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
+
+    constructor() {
+        super();
+    }
+
+    connect(auth, opts) {
+        if (this.leap) {
+            return;
+        }
 
-    const connectionStateUpdate = async state => {
-      this.emit('CONNECTION_STATE_UPDATE', state);
-      await this.handleConnectionStateUpdate(state);
-    };
+        const leap = this.getLeap(auth, opts);
 
-    leap.on('serviceEvent', serviceEvent);
-    leap.on('connectionStateUpdate', connectionStateUpdate);
-  }
-
-  subscribeToRoom(joinToken) {
-    const existingSubscription = this.roomStateMap.get(joinToken);
-    const payload = {
-      e: 'PIPE_ROOM_SUBSCRIBE',
-      c: null,
-      d: {
-        join_token: joinToken
-      }
-    };
+        const serviceEvent = async (message) => {
+            this.emit('SERVICE_EVENT', message);
+            await this.handleServiceEvent(message);
+        };
 
-    if (existingSubscription) {
-      if (existingSubscription.subscription === 'unavailable') {
-        this.send(payload);
-      }
-
-      return;
-    }
-
-    this.send(payload);
-    this.roomStateMap.set(joinToken, {
-      subscription: 'pending',
-      room: null
-    });
-  }
-
-  unsubscribeFromRoom(joinToken) {
-    const stream = this.roomStateMap.get(joinToken);
-
-    if (!stream) {
-      throw new Error('Not subscribed to that room!');
-    } // This condition is annoying, because we don't know the room ID
-    // as we never received 'AVAILABLE'
-    // but we still want to make sure its no longer in this.roomStateMap
-    // and that the server isn't still processing our subscription
-    // Context: An app where there are multiple streams of something
-    // 1) User enters stream and subscribes (we don't receive PIPE_ROOM_AVAILABLE yet)
-    // 2) User realises they pressed wrong stream and quickly hits back
-    // 3) We never got the available message, so we never got the room id
-    // 4) How unsibcsribe
-    // This is a bit of a hack, but it works
-
-
-    if (stream.subscription !== 'available') {
-      const listener = message => {
-        if (message.eventType !== 'PIPE_ROOM_AVAILABLE') {
-          return;
-        }
+        const connectionStateUpdate = async (state) => {
+            this.emit('CONNECTION_STATE_UPDATE', state);
+            await this.handleConnectionStateUpdate(state);
+        };
 
-        this.unsubscribeFromRoom(joinToken);
-        this.rawServiceEventListeners.delete(listener);
-      };
-
-      this.rawServiceEventListeners.add(listener);
-      return;
-    }
-
-    this.roomStateMap.delete(joinToken);
-    this.send({
-      e: 'PIPE_ROOM_UNSUBSCRIBE',
-      d: {
-        id: stream.room.id
-      },
-      c: null
-    });
-  }
-
-  addMessageSubscription(channel, eventName, listener) {
-    const map = this.getChannelMessageListeners();
-    const key = getMessageListenerKey(channel, eventName);
-    const listeners = map.get(key) ?? new Set();
-    const castListener = listener;
-    map.set(key, listeners.add(castListener));
-    return () => {
-      const currentListeners = map.get(key);
-
-      if (!currentListeners) {
-        return;
-      }
-
-      currentListeners.delete(castListener);
-
-      if (currentListeners.size === 0) {
-        map.delete(key);
-      }
-    };
-  }
-  /**
-   * Get a list of pending subscriptions
-   * @returns A list of all channel and room names we are currently subscribed to
-   */
+        leap.on('serviceEvent', serviceEvent);
+        leap.on('connectionStateUpdate', connectionStateUpdate);
+    }
 
+    subscribeToRoom(joinToken) {
+        const existingSubscription = this.roomStateMap.get(joinToken);
+        const payload = {
+            e: 'PIPE_ROOM_SUBSCRIBE',
+            c: null,
+            d: {
+                join_token: joinToken,
+            },
+        };
 
-  getCurrentPendingSubscriptions() {
-    const filter = value => [...value.entries()].filter(([, entry]) => entry.subscription === 'pending').map(entry => entry[0]);
+        if (existingSubscription) {
+            if (existingSubscription.subscription === 'unavailable') {
+                this.send(payload);
+            }
 
-    return {
-      channels: filter(this.getChannelStateMap()),
-      rooms: filter(this.getRoomStateMap())
-    };
-  }
+            return;
+        }
 
-  getChannelStateMap() {
-    return this.channelStateMap;
-  }
+        this.send(payload);
+        this.roomStateMap.set(joinToken, {
+            subscription: 'pending',
+            room: null,
+        });
+    }
 
-  getRoomStateMap() {
-    return this.roomStateMap;
-  }
+    unsubscribeFromRoom(joinToken) {
+        const stream = this.roomStateMap.get(joinToken);
+
+        if (!stream) {
+            throw new Error('Not subscribed to that room!');
+        } // This condition is annoying, because we don't know the room ID
+        // as we never received 'AVAILABLE'
+        // but we still want to make sure its no longer in this.roomStateMap
+        // and that the server isn't still processing our subscription
+        // Context: An app where there are multiple streams of something
+        // 1) User enters stream and subscribes (we don't receive PIPE_ROOM_AVAILABLE yet)
+        // 2) User realises they pressed wrong stream and quickly hits back
+        // 3) We never got the available message, so we never got the room id
+        // 4) How unsibcsribe
+        // This is a bit of a hack, but it works
+
+        if (stream.subscription !== 'available') {
+            const listener = (message) => {
+                if (message.eventType !== 'PIPE_ROOM_AVAILABLE') {
+                    return;
+                }
+
+                this.unsubscribeFromRoom(joinToken);
+                this.rawServiceEventListeners.delete(listener);
+            };
+
+            this.rawServiceEventListeners.add(listener);
+            return;
+        }
 
-  getChannelMessageListeners() {
-    return this.channelMessageListeners;
-  }
+        this.roomStateMap.delete(joinToken);
+        this.send({
+            e: 'PIPE_ROOM_UNSUBSCRIBE',
+            d: {
+                id: stream.room.id,
+            },
+            c: null,
+        });
+    }
 
-  getDirectMessageListeners() {
-    return this.directMessageListeners;
-  }
+    addMessageSubscription(channel, eventName, listener) {
+        const map = this.getChannelMessageListeners();
+        const key = getMessageListenerKey(channel, eventName);
+        const listeners = map.get(key) ?? new Set();
+        const castListener = listener;
+        map.set(key, listeners.add(castListener));
+        return () => {
+            const currentListeners = map.get(key);
 
-  getConnectionState(fullAtom = false) {
-    if (fullAtom) {
-      return this.connectionState;
+            if (!currentListeners) {
+                return;
+            }
+
+            currentListeners.delete(castListener);
+
+            if (currentListeners.size === 0) {
+                map.delete(key);
+            }
+        };
     }
+    /**
+     * Get a list of pending subscriptions
+     * @returns A list of all channel and room names we are currently subscribed to
+     */
 
-    return this.connectionState.get();
-  }
+    getCurrentPendingSubscriptions() {
+        const filter = (value) =>
+            [...value.entries()]
+                .filter(([, entry]) => entry.subscription === 'pending')
+                .map((entry) => entry[0]);
 
-  subscribeToChannel(channel) {
-    const c = this.channelStateMap.get(channel);
+        return {
+            channels: filter(this.getChannelStateMap()),
+            rooms: filter(this.getRoomStateMap()),
+        };
+    }
 
-    if (c && c.subscription === 'available') {
-      return;
+    getChannelStateMap() {
+        return this.channelStateMap;
     }
 
-    const state = {
-      subscription: 'pending',
-      state: c?.state ?? null,
-      error: null
-    };
-    this.channelStateMap.set(channel, state);
-    this.send({
-      e: 'SUBSCRIBE',
-      d: null,
-      c: channel
-    });
-    return state;
-  }
-
-  unsubscribeFromChannel(channel) {
-    this.channelStateMap.delete(channel);
-    this.send({
-      e: 'UNSUBSCRIBE',
-      d: null,
-      c: channel
-    });
-  }
-
-  setChannelState(channel, state) {
-    this.send({
-      e: 'SET_CHANNEL_STATE',
-      c: channel,
-      d: state
-    });
-  }
-
-  sendMessage(channel, event, payload) {
-    this.send({
-      e: 'MESSAGE',
-      c: channel,
-      d: {
-        e: event,
-        d: payload
-      }
-    });
-  }
-
-  async handleConnectionStateUpdate(state) {
-    if (state === LeapConnectionState.ERRORED && this.hasPreviouslyConnected) {
-      for (const ch of this.channelStateMap.keys()) {
-        this.channelStateMap.patch(ch, {
-          subscription: 'pending'
-        });
-      }
+    getRoomStateMap() {
+        return this.roomStateMap;
+    }
 
-      const unsubscribe = this.connectionState.addListener(state => {
-        if (state !== LeapConnectionState.CONNECTED) {
-          return;
-        } // If we have a leap token, subscriptions are persisted
-        // on the server. There's no need to resubscribe.
+    getChannelMessageListeners() {
+        return this.channelMessageListeners;
+    }
 
+    getDirectMessageListeners() {
+        return this.directMessageListeners;
+    }
 
-        if (!this.getLeap().auth.token) {
-          this.resubscribe();
+    getConnectionState(fullAtom = false) {
+        if (fullAtom) {
+            return this.connectionState;
         }
 
-        unsubscribe();
-      });
+        return this.connectionState.get();
     }
 
-    if (!this.hasPreviouslyConnected) {
-      this.hasPreviouslyConnected = true;
-    }
+    subscribeToChannel(channel) {
+        const c = this.channelStateMap.get(channel);
 
-    this.connectionState.set(state);
-  }
+        if (c && c.subscription === 'available') {
+            return;
+        }
 
-  resubscribe() {
-    const {
-      channels,
-      rooms
-    } = this.getCurrentPendingSubscriptions();
+        const state = {
+            subscription: 'pending',
+            state: c?.state ?? null,
+            error: null,
+        };
+        this.channelStateMap.set(channel, state);
+        this.send({
+            e: 'SUBSCRIBE',
+            d: null,
+            c: channel,
+        });
+        return state;
+    }
 
-    for (const channel of channels) {
-      this.subscribeToChannel(channel);
+    unsubscribeFromChannel(channel) {
+        this.channelStateMap.delete(channel);
+        this.send({
+            e: 'UNSUBSCRIBE',
+            d: null,
+            c: channel,
+        });
+    }
+
+    setChannelState(channel, state) {
+        this.send({
+            e: 'SET_CHANNEL_STATE',
+            c: channel,
+            d: state,
+        });
     }
 
-    for (const room of rooms) {
-      this.subscribeToRoom(room);
+    sendMessage(channel, event, payload) {
+        this.send({
+            e: 'MESSAGE',
+            c: channel,
+            d: {
+                e: event,
+                d: payload,
+            },
+        });
     }
-  }
 
-  async handleServiceEvent(event) {
-    const handler = Client.SUPPORTED_EVENTS[event.eventType];
+    async handleConnectionStateUpdate(state) {
+        if (
+            state === LeapConnectionState.ERRORED &&
+            this.hasPreviouslyConnected
+        ) {
+            for (const ch of this.channelStateMap.keys()) {
+                this.channelStateMap.patch(ch, {
+                    subscription: 'pending',
+                });
+            }
+
+            const unsubscribe = this.connectionState.addListener((state) => {
+                if (state !== LeapConnectionState.CONNECTED) {
+                    return;
+                } // If we have a leap token, subscriptions are persisted
+                // on the server. There's no need to resubscribe.
+
+                if (!this.getLeap().auth.token) {
+                    this.resubscribe();
+                }
+
+                unsubscribe();
+            });
+        }
+
+        if (!this.hasPreviouslyConnected) {
+            this.hasPreviouslyConnected = true;
+        }
 
-    if (!handler) {
-      console.warn('[@onehop/client] Channels: Received unsupported opcode!', event);
-      return;
+        this.connectionState.set(state);
     }
 
-    try {
-      await handler.handle(this, event);
-    } catch (error) {
-      console.warn('[@onehop/client] Handling service message failed');
-      console.warn(error);
+    resubscribe() {
+        const { channels, rooms } = this.getCurrentPendingSubscriptions();
+
+        for (const channel of channels) {
+            this.subscribeToChannel(channel);
+        }
+
+        for (const room of rooms) {
+            this.subscribeToRoom(room);
+        }
     }
-  }
 
-  send(data) {
-    this.getLeap().sendServicePayload(data);
-  }
+    async handleServiceEvent(event) {
+        const handler = Client.SUPPORTED_EVENTS[event.eventType];
 
-  getLeap(auth, opts) {
-    if (this.leap) {
-      if (auth) {
-        this.leap.auth = auth;
-      }
+        if (!handler) {
+            console.warn(
+                '[@onehop/client] Channels: Received unsupported opcode!',
+                event
+            );
+            return;
+        }
 
-      return this.leap;
+        try {
+            await handler.handle(this, event);
+        } catch (error) {
+            console.warn('[@onehop/client] Handling service message failed');
+            console.warn(error);
+        }
     }
 
-    if (!auth) {
-      throw new Error('Cannot create a new Leap instance as no authentication params were provided');
+    send(data) {
+        this.getLeap().sendServicePayload(data);
     }
 
-    this.leap = new LeapEdgeClient(auth, opts);
-    this.leap.connect();
-    return this.leap;
-  }
+    getLeap(auth, opts) {
+        if (this.leap) {
+            if (auth) {
+                this.leap.auth = auth;
+            }
+
+            return this.leap;
+        }
+
+        if (!auth) {
+            throw new Error(
+                'Cannot create a new Leap instance as no authentication params were provided'
+            );
+        }
 
+        this.leap = new LeapEdgeClient(auth, opts);
+        this.leap.connect();
+        return this.leap;
+    }
 }
 const instance = new Client();
 
 function init(leapConnectionParams, options) {
-  instance.connect(leapConnectionParams, options?.leapSocketUrl ? {
-    socketUrl: options.leapSocketUrl,
-    debug: false
-  } : undefined);
-  return instance;
+    instance.connect(
+        leapConnectionParams,
+        options?.leapSocketUrl
+            ? {
+                  socketUrl: options.leapSocketUrl,
+                  debug: false,
+              }
+            : undefined
+    );
+    return instance;
 }
 
-var hop = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	init: init
+var hop = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    init: init,
 });
 
-var index$1 = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	Client: Client,
-	instance: instance
+var index$1 = /*#__PURE__*/ Object.freeze({
+    __proto__: null,
+    Client: Client,
+    instance: instance,
 });
-
-const APPLE_HLS_MIME = 'application/vnd.apple.mpegurl';
-const LIVE_LLHLS_SYNC_BCE = 3;
-const WCL_DELAY_LES = 5;
-const defaultConfig = {
-  lowLatencyMode: true,
-  backBufferLength: 10,
-  autoStartLoad: true,
-  enableWorker: true,
-  abrBandWidthFactor: 1,
-  liveSyncDuration: LIVE_LLHLS_SYNC_BCE
-};
-class Controls {
-  constructor(node, hls) {
-    this.node = node;
-    this._hls = hls;
-  }
-  /**
-   * Syncs to live edge
-   *
-   * @param distance The seconds to sync from live edge (e.g. a buffer)
-   */
-
-
-  sync(distance = LIVE_LLHLS_SYNC_BCE) {
-    this.node.currentTime = this.node.duration - distance;
-  }
-
-  async stop() {
-    this.node.pause();
-  }
-
-  async play() {
-    await this.node.play();
-    this.sync(3.5);
-  }
-
-  get isPaused() {
-    return this.node.paused;
-  }
-
-  destroy() {
-    this.hls.destroy();
-  }
-
-  get isNative() {
-    return !this._hls;
-  }
-
-  get hls() {
-    if (!this._hls) {
-      throw new Error('Cannot get HLS instance as video is being streamed natively.');
-    }
-
-    return this._hls;
-  }
-
-}
-function mount(node, url, hlsConfigOverride) {
-  let instance;
-
-  if (Hls__default.isSupported()) {
-    instance = new Hls__default({ ...defaultConfig,
-      ...hlsConfigOverride
-    });
-  } else if (node.canPlayType(APPLE_HLS_MIME)) {
-    node.src = url;
-    return new Controls(node);
-  } else {
-    throw new Error('HLS Will not work in this browser', {
-      cause: new Error('This browser does not support HLS or MSE: https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API')
-    });
-  }
-
-  const syncToBCE = () => {
-    if (node.duration < LIVE_LLHLS_SYNC_BCE) {
-      return;
-    }
-
-    node.currentTime = node.duration - LIVE_LLHLS_SYNC_BCE;
-  };
-
-  node.onplay = () => {
-    syncToBCE();
-  };
-
-  const liveSync = setInterval(() => {
-    if (node && !node.paused && instance.latency > LIVE_LLHLS_SYNC_BCE + WCL_DELAY_LES) {
-      syncToBCE();
-    }
-  }, 1000);
-  instance.on(Hls__default.Events.MEDIA_DETACHING, () => {
-    clearInterval(liveSync);
-  });
-  instance.loadSource(url);
-  instance.attachMedia(node);
-  return new Controls(node, instance);
-}
-
-var index = /*#__PURE__*/Object.freeze({
-	__proto__: null,
-	APPLE_HLS_MIME: APPLE_HLS_MIME,
-	LIVE_LLHLS_SYNC_BCE: LIVE_LLHLS_SYNC_BCE,
-	WCL_DELAY_LES: WCL_DELAY_LES,
-	Controls: Controls,
-	mount: mount
-});
-
-export { hop, index$1 as leap, index as pipe, index$2 as util };